-- === MASTER DATA & SECURITY ===
CREATE TABLE users (
  user_id   SERIAL PRIMARY KEY,
  username  VARCHAR(100) UNIQUE NOT NULL,
  full_name VARCHAR(255),
  email     VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE roles (
  role_id SERIAL PRIMARY KEY,
  name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE user_roles (
  user_id INT REFERENCES users(user_id),
  role_id INT REFERENCES roles(role_id),
  PRIMARY KEY (user_id, role_id)
);

-- === CURRENCIES & RATES ===
CREATE TABLE currencies (
  currency_code CHAR(3) PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  decimal_places INT NOT NULL DEFAULT 2
);

CREATE TABLE exchange_rates (
  exchange_rate_id SERIAL PRIMARY KEY,
  base_currency CHAR(3) NOT NULL REFERENCES currencies(currency_code),
  target_currency CHAR(3) NOT NULL REFERENCES currencies(currency_code),
  rate NUMERIC(24,12) NOT NULL,
  rate_date DATE NOT NULL,
  UNIQUE (base_currency, target_currency, rate_date)
);

-- === COMPANIES / DIMENSIONS ===
CREATE TABLE companies (
  company_id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  legal_entity_name VARCHAR(255),
  currency_code CHAR(3) REFERENCES currencies(currency_code),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE business_units (
  business_unit_id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  company_id INT NOT NULL REFERENCES companies(company_id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE cost_centers (
  cost_center_id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  company_id INT NOT NULL REFERENCES companies(company_id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- optional segmentation for multi-dimensional ledgers
CREATE TABLE segments (
  segment_id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  description TEXT
);

-- === CHART OF ACCOUNTS & CLASSIFICATION ===
CREATE TABLE chart_of_accounts (
  account_id SERIAL PRIMARY KEY,
  account_number VARCHAR(50) UNIQUE NOT NULL,
  account_name VARCHAR(255) NOT NULL,
  account_type VARCHAR(50) NOT NULL CHECK (account_type IN ('Asset','Liability','Equity','Revenue','Expense')),
  account_class VARCHAR(50),
  parent_account_id INT REFERENCES chart_of_accounts(account_id),
  is_header BOOLEAN NOT NULL DEFAULT FALSE,
  allow_postings BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- === FISCAL PERIODS / YEAR ===
CREATE TABLE fiscal_years (
  fiscal_year_id SERIAL PRIMARY KEY,
  company_id INT NOT NULL REFERENCES companies(company_id),
  year_label VARCHAR(20) NOT NULL,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  is_closed BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE TABLE fiscal_periods (
  fiscal_period_id SERIAL PRIMARY KEY,
  fiscal_year_id INT NOT NULL REFERENCES fiscal_years(fiscal_year_id),
  period_label VARCHAR(20) NOT NULL,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  is_closed BOOLEAN NOT NULL DEFAULT FALSE,
  UNIQUE (fiscal_year_id, period_label)
);

-- === JOURNALS, TYPES, AND WORKFLOW ===
CREATE TABLE journal_types (
  journal_type_id SERIAL PRIMARY KEY,
  code VARCHAR(20) UNIQUE NOT NULL, -- e.g. AP, AR, GL, CASH
  name VARCHAR(100) NOT NULL
);

CREATE TABLE journals (
  journal_id SERIAL PRIMARY KEY,
  company_id INT NOT NULL REFERENCES companies(company_id),
  journal_type_id INT REFERENCES journal_types(journal_type_id),
  name VARCHAR(100),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE journal_entries (
  journal_entry_id SERIAL PRIMARY KEY,
  journal_id INT REFERENCES journals(journal_id),
  transaction_date DATE NOT NULL,
  fiscal_period_id INT REFERENCES fiscal_periods(fiscal_period_id),
  description TEXT,
  document_reference_id INT,
  currency_code CHAR(3) REFERENCES currencies(currency_code),
  exchange_rate NUMERIC(24,12) DEFAULT 1.0,
  status VARCHAR(20) NOT NULL DEFAULT 'Draft' CHECK (status IN ('Draft','Posted','Reversed','Cancelled')),
  created_by INT REFERENCES users(user_id),
  posted_by INT REFERENCES users(user_id),
  posted_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE journal_details (
  journal_detail_id SERIAL PRIMARY KEY,
  journal_entry_id INT NOT NULL REFERENCES journal_entries(journal_entry_id),
  account_id INT NOT NULL REFERENCES chart_of_accounts(account_id),
  company_id INT NOT NULL REFERENCES companies(company_id),
  business_unit_id INT REFERENCES business_units(business_unit_id),
  cost_center_id INT REFERENCES cost_centers(cost_center_id),
  segment_id INT REFERENCES segments(segment_id),
  debit_amount NUMERIC(24,8) NOT NULL DEFAULT 0 CHECK (debit_amount >= 0),
  credit_amount NUMERIC(24,8) NOT NULL DEFAULT 0 CHECK (credit_amount >= 0),
  narrative TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

ALTER TABLE journal_details
  ADD CONSTRAINT chk_one_side_only CHECK (
    (debit_amount > 0 AND credit_amount = 0) OR
    (credit_amount > 0 AND debit_amount = 0)
  );

-- === ACCOUNT BALANCES / SNAPSHOTS ===
CREATE TABLE account_balances (
  account_balance_id SERIAL PRIMARY KEY,
  account_id INT NOT NULL REFERENCES chart_of_accounts(account_id),
  company_id INT NOT NULL REFERENCES companies(company_id),
  balance_date DATE NOT NULL,
  balance NUMERIC(24,8) NOT NULL DEFAULT 0,
  UNIQUE (account_id, company_id, balance_date)
);

-- === AP / VENDORS & PAYMENTS ===
CREATE TABLE vendors (
  vendor_id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  contact_name VARCHAR(255),
  contact_email VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE purchase_orders (
  purchase_order_id SERIAL PRIMARY KEY,
  vendor_id INT NOT NULL REFERENCES vendors(vendor_id),
  purchase_date DATE NOT NULL,
  status VARCHAR(50) NOT NULL CHECK (status IN ('Draft','Issued','Received','Invoiced','Closed')),
  total_amount NUMERIC(19,4) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE bills (
  bill_id SERIAL PRIMARY KEY,
  vendor_id INT NOT NULL REFERENCES vendors(vendor_id),
  purchase_order_id INT REFERENCES purchase_orders(purchase_order_id),
  bill_date DATE NOT NULL,
  due_date DATE NOT NULL,
  currency_code CHAR(3) REFERENCES currencies(currency_code),
  total_amount NUMERIC(19,4) NOT NULL,
  is_paid BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE payments (
  payment_id SERIAL PRIMARY KEY,
  bill_id INT REFERENCES bills(bill_id),
  payment_date DATE NOT NULL,
  amount NUMERIC(19,4) NOT NULL,
  method VARCHAR(50),
  bank_account_id INT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE payment_allocations (
  payment_allocation_id SERIAL PRIMARY KEY,
  payment_id INT REFERENCES payments(payment_id) ON DELETE CASCADE,
  invoice_id INT, -- can allocate between AR invoices or bills etc.
  bill_id INT,
  amount NUMERIC(19,4) NOT NULL
);

-- === AR / CUSTOMERS & INVOICING ===
CREATE TABLE customers (
  customer_id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  contact_name VARCHAR(255),
  contact_email VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE sales_orders (
  sales_order_id SERIAL PRIMARY KEY,
  customer_id INT NOT NULL REFERENCES customers(customer_id),
  order_date DATE NOT NULL,
  status VARCHAR(50) NOT NULL CHECK (status IN ('Draft','Confirmed','Fulfilled','Invoiced','Closed')),
  total_amount NUMERIC(19,4) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE invoices (
  invoice_id SERIAL PRIMARY KEY,
  customer_id INT NOT NULL REFERENCES customers(customer_id),
  sales_order_id INT REFERENCES sales_orders(sales_order_id),
  invoice_date DATE NOT NULL,
  due_date DATE NOT NULL,
  currency_code CHAR(3) REFERENCES currencies(currency_code),
  total_amount NUMERIC(19,4) NOT NULL,
  is_paid BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- tax lines for invoices and bills
CREATE TABLE tax_codes (
  tax_code_id SERIAL PRIMARY KEY,
  code VARCHAR(20) UNIQUE NOT NULL,
  description TEXT,
  rate NUMERIC(8,6) NOT NULL
);

CREATE TABLE tax_lines (
  tax_line_id SERIAL PRIMARY KEY,
  invoice_id INT REFERENCES invoices(invoice_id),
  bill_id INT REFERENCES bills(bill_id),
  tax_code_id INT REFERENCES tax_codes(tax_code_id),
  taxable_amount NUMERIC(19,4) NOT NULL,
  tax_amount NUMERIC(19,4) NOT NULL
);

-- === FIXED ASSETS & DEPRECIATION ===
CREATE TABLE fixed_assets (
  asset_id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  company_id INT NOT NULL REFERENCES companies(company_id),
  purchase_date DATE NOT NULL,
  purchase_cost NUMERIC(19,4) NOT NULL,
  depreciation_method VARCHAR(50) NOT NULL,
  useful_life_years INT NOT NULL,
  accumulated_depreciation NUMERIC(19,4) NOT NULL DEFAULT 0,
  disposal_date DATE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE depreciation_entries (
  depreciation_entry_id SERIAL PRIMARY KEY,
  asset_id INT NOT NULL REFERENCES fixed_assets(asset_id),
  depreciation_date DATE NOT NULL,
  amount NUMERIC(19,4) NOT NULL,
  journal_entry_id INT NOT NULL REFERENCES journal_entries(journal_entry_id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- === INVENTORY ===
CREATE TABLE inventory_items (
  item_id SERIAL PRIMARY KEY,
  sku VARCHAR(100) UNIQUE NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  cost NUMERIC(19,4) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE inventory_transactions (
  inventory_transaction_id SERIAL PRIMARY KEY,
  item_id INT NOT NULL REFERENCES inventory_items(item_id),
  transaction_date DATE NOT NULL,
  transaction_type VARCHAR(50) NOT NULL CHECK (transaction_type IN ('Purchase','Sale','Adjustment','Transfer')),
  quantity INT NOT NULL,
  unit_cost NUMERIC(19,4) NOT NULL,
  total_cost NUMERIC(19,4) NOT NULL,
  journal_entry_id INT REFERENCES journal_entries(journal_entry_id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- === BANKS & RECONCILIATION ===
CREATE TABLE bank_accounts (
  bank_account_id SERIAL PRIMARY KEY,
  company_id INT NOT NULL REFERENCES companies(company_id),
  bank_name VARCHAR(255),
  account_number VARCHAR(100),
  currency_code CHAR(3) REFERENCES currencies(currency_code),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE bank_transactions (
  bank_tx_id SERIAL PRIMARY KEY,
  bank_account_id INT REFERENCES bank_accounts(bank_account_id),
  tx_date DATE NOT NULL,
  amount NUMERIC(19,4) NOT NULL,
  description TEXT,
  imported BOOLEAN DEFAULT FALSE
);

CREATE TABLE bank_reconciliations (
  reconciliation_id SERIAL PRIMARY KEY,
  bank_account_id INT REFERENCES bank_accounts(bank_account_id),
  from_date DATE,
  to_date DATE,
  reconciled_at TIMESTAMP,
  reconciled_by INT REFERENCES users(user_id)
);

-- === PROJECTS & BUDGETS ===
CREATE TABLE projects (
  project_id SERIAL PRIMARY KEY,
  company_id INT NOT NULL REFERENCES companies(company_id),
  name VARCHAR(255) NOT NULL,
  start_date DATE,
  end_date DATE,
  manager_id INT REFERENCES users(user_id)
);

CREATE TABLE project_lines (
  project_line_id SERIAL PRIMARY KEY,
  project_id INT NOT NULL REFERENCES projects(project_id),
  account_id INT NOT NULL REFERENCES chart_of_accounts(account_id),
  amount NUMERIC(24,8) NOT NULL
);

CREATE TABLE budgets (
  budget_id SERIAL PRIMARY KEY,
  company_id INT NOT NULL REFERENCES companies(company_id),
  fiscal_period_id INT REFERENCES fiscal_periods(fiscal_period_id),
  account_id INT NOT NULL REFERENCES chart_of_accounts(account_id),
  amount NUMERIC(24,8) NOT NULL
);

-- === RECURRING / TEMPLATES / APPROVALS ===
CREATE TABLE recurring_journal_templates (
  template_id SERIAL PRIMARY KEY,
  name VARCHAR(255),
  frequency VARCHAR(50), -- e.g. Monthly, Quarterly
  next_run DATE,
  created_by INT REFERENCES users(user_id)
);

CREATE TABLE recurring_template_lines (
  template_line_id SERIAL PRIMARY KEY,
  template_id INT REFERENCES recurring_journal_templates(template_id),
  account_id INT REFERENCES chart_of_accounts(account_id),
  debit_amount NUMERIC(24,8) DEFAULT 0,
  credit_amount NUMERIC(24,8) DEFAULT 0
);

CREATE TABLE approvals (
  approval_id SERIAL PRIMARY KEY,
  object_type VARCHAR(50),
  object_id INT,
  approver_id INT REFERENCES users(user_id),
  status VARCHAR(20) CHECK (status IN ('Pending','Approved','Rejected')),
  comments TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  acted_at TIMESTAMP
);

-- === DOCUMENTS & AUDIT LOG ===
CREATE TABLE documents (
  document_id SERIAL PRIMARY KEY,
  object_type VARCHAR(50),
  object_id INT,
  file_name VARCHAR(255),
  mime_type VARCHAR(100),
  storage_uri TEXT,
  uploaded_by INT REFERENCES users(user_id),
  uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE audit_logs (
  audit_id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(user_id),
  action VARCHAR(50) NOT NULL,
  object_type VARCHAR(50),
  object_id INT,
  details JSONB,
  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- === INTERCOMPANY & CONSOLIDATION ===
CREATE TABLE intercompany_flags (
  ic_flag_id SERIAL PRIMARY KEY,
  description TEXT
);

CREATE TABLE intercompany_entries (
  ic_entry_id SERIAL PRIMARY KEY,
  originating_company_id INT REFERENCES companies(company_id),
  receiving_company_id INT REFERENCES companies(company_id),
  journal_entry_id INT REFERENCES journal_entries(journal_entry_id)
);

-- === INDEXES ===
CREATE INDEX idx_jd_account ON journal_details(account_id);
CREATE INDEX idx_jd_journal_entry ON journal_details(journal_entry_id);
CREATE INDEX idx_journal_entries_status ON journal_entries(status);
CREATE INDEX idx_invoices_customer_date ON invoices(customer_id, invoice_date);
CREATE INDEX idx_bills_vendor ON bills(vendor_id);

-- === TRIGGERS & BASIC ENFORCEMENTS ===
-- 1) Enforce minimum two lines and balance when posting
CREATE OR REPLACE FUNCTION fn_check_entry_balanced()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
DECLARE
  sum_debit NUMERIC;
  sum_credit NUMERIC;
  line_count INT;
BEGIN
  IF TG_OP = 'UPDATE' AND NEW.status = 'Posted' AND OLD.status IS DISTINCT FROM NEW.status THEN
    SELECT COUNT(*) INTO line_count FROM journal_details WHERE journal_entry_id = NEW.journal_entry_id;
    IF line_count < 2 THEN
      RAISE EXCEPTION 'Cannot post: entry must have at least two lines.';
    END IF;
    SELECT COALESCE(SUM(debit_amount),0) INTO sum_debit FROM journal_details WHERE journal_entry_id = NEW.journal_entry_id;
    SELECT COALESCE(SUM(credit_amount),0) INTO sum_credit FROM journal_details WHERE journal_entry_id = NEW.journal_entry_id;
    IF round(sum_debit::numeric,8) <> round(sum_credit::numeric,8) THEN
      RAISE EXCEPTION 'Cannot post: debits (%.8f) != credits (%.8f).', sum_debit, sum_credit;
    END IF;
    IF NEW.fiscal_period_id IS NULL THEN
      RAISE EXCEPTION 'Cannot post: fiscal_period_id required.';
    END IF;
    NEW.posted_at := COALESCE(NEW.posted_at, now());
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_check_entry_balanced
  BEFORE UPDATE ON journal_entries
  FOR EACH ROW
  WHEN (NEW.status = 'Posted')
  EXECUTE FUNCTION fn_check_entry_balanced();

-- 2) Apply lines to account_balances after posting
CREATE OR REPLACE FUNCTION fn_apply_journal_to_balances()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
DECLARE
  rec RECORD;
  delta NUMERIC;
BEGIN
  IF TG_OP = 'UPDATE' AND NEW.status = 'Posted' AND OLD.status IS DISTINCT FROM NEW.status THEN
    FOR rec IN SELECT account_id, company_id, debit_amount, credit_amount FROM journal_details WHERE journal_entry_id = NEW.journal_entry_id
    LOOP
      delta := COALESCE(rec.debit_amount,0) - COALESCE(rec.credit_amount,0);
      INSERT INTO account_balances (account_id, company_id, balance_date, balance)
        VALUES (rec.account_id, rec.company_id, NEW.transaction_date, delta)
      ON CONFLICT (account_id, company_id, balance_date)
      DO UPDATE SET balance = account_balances.balance + EXCLUDED.balance;
    END LOOP;
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_apply_to_balances
  AFTER UPDATE ON journal_entries
  FOR EACH ROW
  WHEN (NEW.status = 'Posted')
  EXECUTE FUNCTION fn_apply_journal_to_balances();

-- 3) Prevent modification of posted journal_details (immutability)
CREATE OR REPLACE FUNCTION fn_prevent_mod_posted_details()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
DECLARE
  parent_status TEXT;
BEGIN
  SELECT status INTO parent_status FROM journal_entries WHERE journal_entry_id = NEW.journal_entry_id;
  IF parent_status = 'Posted' THEN
    RAISE EXCEPTION 'Cannot modify journal detail: parent entry is Posted. Create reversing entry instead.';
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_prevent_mod_posted_details
  BEFORE UPDATE OR DELETE ON journal_details
  FOR EACH ROW
  EXECUTE FUNCTION fn_prevent_mod_posted_details();

-- 4) Audit log trigger (simple)
CREATE OR REPLACE FUNCTION fn_audit_journal_entries()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO audit_logs(user_id, action, object_type, object_id, details)
  VALUES (NEW.posted_by, TG_OP || ' journal_entry', 'journal_entry', NEW.journal_entry_id,
          jsonb_build_object('old', row_to_json(OLD), 'new', row_to_json(NEW)));
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_audit_journal_entries
  AFTER UPDATE ON journal_entries
  FOR EACH ROW
  WHEN (OLD.* IS DISTINCT FROM NEW.*)
  EXECUTE FUNCTION fn_audit_journal_entries();

-- === NOTES & NEXT STEPS ===
-- 1) Add foreign key references for posted_by/created_by to your authentication users if different.
-- 2) Replace SERIAL with BIGSERIAL for high-volume systems.
-- 3) Normalize amounts to a consistent scale. Consider storing amounts in minor units for performance.
-- 4) Add more granular permission checks in application layer or via RLS policies.
-- 5) For high-throughput ledger use append-only ledger tables and periodic snapshotting rather than per-line balance updates.

